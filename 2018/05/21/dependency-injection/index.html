<!DOCTYPE html><html lang="en_US"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Dependency Injection in a nutshell · From Noobs To Geeks</title><meta name="description" content="Dependency Injection in a nutshell - khanhtc"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/images/larry-hi.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://fromnoobstogeeks.com/atom.xml" title="From Noobs To Geeks"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/images/larry-hi.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="/about/" target="_self" class="nav-list-link">ABOUT</a></li><li class="nav-list-item"><a href="/projects/" target="_self" class="nav-list-link">PROJECTS</a></li><li class="nav-list-item"><a href="https://github.com/khanhtc1202" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">Dependency Injection in a nutshell</h1><div class="post-info">May 21, 2018</div><div class="post-content"><p>As a developer, we write code day by day, try to handle many things, put all the thing in the right way it should be. Almost of our time is spent to googling usage of libraries (or frameworks), try to handle some incredible bugs or try to maintain some shitty things from other guys you may never ever met. All this mess made us forget about something that really have a meaning, it made us forget that our job is not just try to handle all the things, but our job is focused on <code>creating the new thing depend on another guy achievement</code>. But the reason why we are so confused lies in our purpose. Just like the picture below, sometime you realize yourself that you are just a noob and trying to handle all that mess - the mess named dependencies.</p>
<a id="more"></a>
<p><img src="https://i.imgur.com/U1ahhBd.jpg"></p>
<p>Almost of us know about the SOLID principle, some of us understood and rare of us think about it while we write down our code (I'm not on this group T.T). We all pay our attention on something like design pattern and think about it as the easiest way to know how good your code are, but if we focus on that think too much, the thing we created will become more messed than you think (in the case you can finish what you started).</p>
<p>Our life will get easier if we put our attention on the right way it should be! Good code mean easier to maintain &amp; easier to <code>read</code>, so if you want to make it easier to read, just break it into pieces. But when we have a heap of piece, create application logic like put them together and this makes them dependent on each other.</p>
<p>For example, in the below code block, we call <code>Car</code> class depends on <code>Engine</code> class.</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Car <span class="keyword">struct</span> &#123;</span><br><span class="line">    Engine Engine <span class="comment">// the car has an engine</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This pattern appears so many times in our application. Everything seems to be okay, but when we start writing logic of <code>Car</code> class that have relation with <code>Engine of the Car</code>, all the change on <code>Engine</code> class can make <code>Car</code> class logic be broken. The same thing when we use external libraries, if your application depends directly on the external modules, it will be corrupted when those libraries are updated.</p>
<p>To avoid that dead end, we have a very useful tool named <code>Dependencies Injection</code>. Instead of directly injecting class to class, it's better to inject just the interface of injecting class to the host class (we have many ways to do this strategy).</p>
<h2 id="dependencies-injection-in-sample">Dependencies Injection in sample</h2>
<p>with <code>IEngine</code> is an interface of engine, <code>Car</code> is car class that use <code>IEngine</code></p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> IEngine <span class="keyword">interface</span> &#123;</span><br><span class="line">    Start()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="contructor-injection">Contructor Injection</h3>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Car <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// public prop</span></span><br><span class="line">    Engine IEngine</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Car Contructor</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCar</span><span class="params">(engine IEngine)</span> *<span class="title">Car</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;Car&#123;</span><br><span class="line">        Engine: engine</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// usage</span></span><br><span class="line">runByRiceEngine := NewRunByRiceEngine() <span class="comment">// implemented IEngine interface</span></span><br><span class="line">car := NewCar(runByRiceEngine)</span><br></pre></td></tr></table></figure>
<h3 id="property-injection">Property Injection</h3>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Car <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// private prop</span></span><br><span class="line">    engine IEngine</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Setter</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Car)</span> <span class="title">SetEngine</span><span class="params">(engine IEngine)</span></span> &#123;</span><br><span class="line">    c.engine = engine</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// usage</span></span><br><span class="line">runByRiceEngine := NewRunByRiceEngine() <span class="comment">// implemented IEngine interface</span></span><br><span class="line">car := Car()</span><br><span class="line">car.SetEngine(runByRiceEngine)</span><br></pre></td></tr></table></figure>
<h3 id="interface-injection">Interface Injection</h3>
<p>In some opinion, they think that it's better if the way we inject class into another class is an interface itself. This implementation familiar with property injection, but the inject method isn't setter method. The object class we inject into itself implements the injectable forms on it.</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> IEngineMountable <span class="keyword">interface</span> &#123;</span><br><span class="line">    Mount(engine IEngine)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Car <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// private prop</span></span><br><span class="line">    engine IEngine</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// implement IEngineMountable</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Car)</span> <span class="title">Mount</span><span class="params">(engine IEngine)</span></span> &#123;</span><br><span class="line">    c.engine = engine</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// usage</span></span><br><span class="line">runByRiceEngine := NewRunByRiceEngine() <span class="comment">// implemented IEngine interface</span></span><br><span class="line">car := Car()</span><br><span class="line">car.Mount(runByRiceEngine)</span><br></pre></td></tr></table></figure>
<h2 id="dependencies-injection-and-composition-root">Dependencies Injection and Composition Root</h2>
<p>There is some where in your application, they call its <a href="http://blog.ploeh.dk/2011/07/28/CompositionRoot/" target="_blank" rel="noopener">Composition Root</a>.</p>
<blockquote>
<p>A Composition Root is a (preferably) unique location in an application where modules are composed together.</p>
</blockquote>
<p>It as close as possible to the application's entry point. In there, all of the object we declared through the application will be instanced and be composed together and act the application logic we wrote.</p>
<p>In console application, it should be placed at <code>main</code>. But on another way, it's better to make the <code>main</code> method as lightweight as possible, so we can give that mission to another guy. The below sample, we going to give this mission to the guy name <code>DI Container</code>.</p>
<h3 id="injection-with-di-container">Injection with DI Container</h3>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Builder <span class="function"><span class="keyword">func</span><span class="params">(con *Container)</span> <span class="title">interface</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// definition class</span></span><br><span class="line"><span class="keyword">type</span> Definition <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">    Builder Builder</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DI Container class</span></span><br><span class="line"><span class="keyword">type</span> Container <span class="keyword">struct</span> &#123;</span><br><span class="line">    store <span class="keyword">map</span>[<span class="keyword">string</span>]Builder</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewContainer</span><span class="params">()</span> *<span class="title">Container</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;Container&#123;</span><br><span class="line">        store: <span class="keyword">map</span>[<span class="keyword">string</span>]Builder&#123;&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DI Container method: register the object creation method</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Container)</span> <span class="title">Register</span><span class="params">(d *Definition)</span></span> &#123;</span><br><span class="line">    c.store[d.Name] = d.Builder</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DI Container method: get object from container</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Container)</span> <span class="title">Get</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">    builder, _ := c.store[key]</span><br><span class="line">    instance = builder(c)</span><br><span class="line">    <span class="keyword">return</span> instance</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// usage</span></span><br><span class="line">container := NewContainer()</span><br><span class="line">rd := &amp;Definition&#123;</span><br><span class="line">    Name: <span class="string">"RunByRiceEngine"</span>,</span><br><span class="line">    Builder: <span class="function"><span class="keyword">func</span><span class="params">(con *Container)</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">        <span class="keyword">return</span> NewRunByRiceEngine()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">container.Register(rd)</span><br><span class="line"></span><br><span class="line">sd := &amp;Definition&#123;</span><br><span class="line">    Name: <span class="string">"CarWithRunByRiceEngine"</span>,</span><br><span class="line">    Builder: <span class="function"><span class="keyword">func</span><span class="params">(con *Container)</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">        engine := con.Get(<span class="string">"RunByRiceEngine"</span>).(IEngine)</span><br><span class="line">        <span class="comment">// inject by the way you want! In this case, it's constructor injection</span></span><br><span class="line">        <span class="keyword">return</span> NewCar(engine)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">container.Register(sd)</span><br><span class="line"></span><br><span class="line">... <span class="comment">// in main</span></span><br><span class="line">car := container.Get(<span class="string">"CarWithRunByRiceEngine"</span>)</span><br></pre></td></tr></table></figure>
<p>We can make container store more than just the way to create new objects. For example we can use DI Container for storing object itself (something like Singleton Pattern implemented inside the container), sample code for this go <a href="https://gist.github.com/khanhtc1202/88411fb3e33f7dd4c5e0b11618b87016" target="_blank" rel="noopener">here</a>.</p>
<p>to be continue...</p>
</div></article></div></main><footer><div class="paginator"><a href="/2018/06/05/ninja-code/" class="prev">PREV</a><a href="/2018/04/15/flux-arch/" class="next">NEXT</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'fromnoobstogeeks';
var disqus_identifier = '2018/05/21/dependency-injection/';
var disqus_title = 'Dependency Injection in a nutshell';
var disqus_url = 'https://fromnoobstogeeks.com/2018/05/21/dependency-injection/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//fromnoobstogeeks.disqus.com/count.js" async></script><div class="copyright"><p>© 2017 - 2019 <a href="https://fromnoobstogeeks.com">khanhtc</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>